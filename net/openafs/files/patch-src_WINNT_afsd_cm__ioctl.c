--- src/WINNT/afsd/cm_ioctl.c.orig	2021-01-14 21:08:41 UTC
+++ src/WINNT/afsd/cm_ioctl.c
@@ -2526,151 +2526,6 @@ cm_UsernameToId(char *uname, cm_ucell_t * ucellp, afs_
 }
 #endif /* QUERY_AFSID */
 
-#if 0
-/* This has been copied to smb_IoctlSetToken in its entirety.
- * An equivalent version will need to be produced for the
- * redirector and some extensive refactoring might be required.
- */
-afs_int32
-cm_IoctlSetToken(struct cm_ioctl *ioctlp, struct cm_user *userp)
-{
-    char *saveDataPtr;
-    char *tp;
-    int ticketLen;
-    char *ticket;
-    int ctSize;
-    struct ClearToken ct;
-    cm_cell_t *cellp;
-    cm_ucell_t *ucellp;
-    char *uname = NULL;
-    afs_uuid_t uuid;
-    int flags;
-    char sessionKey[8];
-    char *smbname;
-    int release_userp = 0;
-    char * wdir = NULL;
-
-    saveDataPtr = ioctlp->inDatap;
-
-    cm_SkipIoctlPath(ioctlp);
-
-    tp = ioctlp->inDatap;
-
-    /* ticket length */
-    memcpy(&ticketLen, tp, sizeof(ticketLen));
-    tp += sizeof(ticketLen);
-    if (ticketLen < MINKTCTICKETLEN || ticketLen > MAXKTCTICKETLEN)
-        return CM_ERROR_INVAL;
-
-    /* remember ticket and skip over it for now */
-    ticket = tp;
-    tp += ticketLen;
-
-    /* clear token size */
-    memcpy(&ctSize, tp, sizeof(ctSize));
-    tp += sizeof(ctSize);
-    if (ctSize != sizeof(struct ClearToken))
-        return CM_ERROR_INVAL;
-
-    /* clear token */
-    memcpy(&ct, tp, ctSize);
-    tp += ctSize;
-    if (ct.AuthHandle == -1)
-        ct.AuthHandle = 999;	/* more rxvab compat stuff */
-
-    /* more stuff, if any */
-    if (ioctlp->inCopied > tp - saveDataPtr) {
-        /* flags:  logon flag */
-        memcpy(&flags, tp, sizeof(int));
-        tp += sizeof(int);
-
-        /* cell name */
-        cellp = cm_GetCell(tp, CM_FLAG_CREATE | CM_FLAG_NOPROBE);
-        if (!cellp)
-            return CM_ERROR_NOSUCHCELL;
-        tp += strlen(tp) + 1;
-
-        /* user name */
-        uname = tp;
-        tp += strlen(tp) + 1;
-
-        if (flags & PIOCTL_LOGON) {
-            /* SMB user name with which to associate tokens */
-            smbname = tp;
-            osi_Log2(smb_logp,"cm_IoctlSetToken for user [%s] smbname [%s]",
-                     osi_LogSaveString(smb_logp,uname), osi_LogSaveString(smb_logp,smbname));
-            fprintf(stderr, "SMB name = %s\n", smbname);
-            tp += strlen(tp) + 1;
-        } else {
-            osi_Log1(smb_logp,"cm_IoctlSetToken for user [%s]",
-                     osi_LogSaveString(smb_logp, uname));
-        }
-
-		/* uuid */
-        memcpy(&uuid, tp, sizeof(uuid));
-        if (!cm_FindTokenEvent(uuid, sessionKey))
-            return CM_ERROR_INVAL;
-    } else {
-        cellp = cm_data.rootCellp;
-        osi_Log0(smb_logp,"cm_IoctlSetToken - no name specified");
-    }
-
-    if (flags & PIOCTL_LOGON) {
-        clientchar_t *cname;
-
-        cname = cm_FsStringToClientStringAlloc(smbname, -1, NULL);
-
-        userp = smb_FindCMUserByName(cname, ioctlp->fidp->vcp->rname,
-				     SMB_FLAG_CREATE|SMB_FLAG_AFSLOGON);
-        if (cname)
-            free(cname);
-	release_userp = 1;
-    }
-
-    /* store the token */
-    lock_ObtainMutex(&userp->mx);
-    ucellp = cm_GetUCell(userp, cellp);
-    osi_Log1(smb_logp,"cm_IoctlSetToken ucellp %lx", ucellp);
-    ucellp->ticketLen = ticketLen;
-    if (ucellp->ticketp)
-        free(ucellp->ticketp);	/* Discard old token if any */
-    ucellp->ticketp = malloc(ticketLen);
-    memcpy(ucellp->ticketp, ticket, ticketLen);
-    /*
-     * Get the session key from the RPC, rather than from the pioctl.
-     */
-    /*
-    memcpy(&ucellp->sessionKey, ct.HandShakeKey, sizeof(ct.HandShakeKey));
-    */
-    memcpy(ucellp->sessionKey.data, sessionKey, sizeof(sessionKey));
-    ucellp->kvno = ct.AuthHandle;
-    ucellp->expirationTime = ct.EndTimestamp;
-    ucellp->gen++;
-#ifdef QUERY_AFSID
-    ucellp->uid = ANONYMOUSID;
-#endif
-    if (uname) {
-        StringCbCopyA(ucellp->userName, MAXKTCNAMELEN, uname);
-#ifdef QUERY_AFSID
-	cm_UsernameToId(uname, ucellp, &ucellp->uid);
-#endif
-    }
-    _InterlockedOr(&ucellp->flags, CM_UCELLFLAG_RXKAD);
-    lock_ReleaseMutex(&userp->mx);
-
-    if (flags & PIOCTL_LOGON) {
-        ioctlp->flags |= CM_IOCTLFLAG_LOGON;
-    }
-
-    cm_ResetACLCache(cellp, userp);
-
-    if (release_userp)
-	cm_ReleaseUser(userp);
-
-    return 0;
-}
-#endif
-
 /*
  * VIOC_GETTOK internals.
  *
